<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogger/images/cafecat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogger/images/cafecat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogger/images/cafecat.png">
  <link rel="mask-icon" href="/blogger/images/cafecat.svg" color="#222">

<link rel="stylesheet" href="/blogger/css/main.css">


<link rel="stylesheet" href="/blogger/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liang-shenlin.gitee.io","root":"/blogger/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="吃好喝好，长生不老。">
<meta property="og:type" content="website">
<meta property="og:title" content="E0005105">
<meta property="og:url" content="http://liang-shenlin.gitee.io/blogger/index.html">
<meta property="og:site_name" content="E0005105">
<meta property="og:description" content="吃好喝好，长生不老。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="梁申麟">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liang-shenlin.gitee.io/blogger/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>E0005105</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>



<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogger/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">E0005105</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录工作中遇到的一些问题</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogger/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blogger/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blogger/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogger/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogger/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">11</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2022/02/09/vscode-qemu%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2022/02/09/vscode-qemu%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">vscode+qemu调试代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-09 15:09:15 / 修改时间：15:54:49" itemprop="dateCreated datePublished" datetime="2022-02-09T15:09:15+08:00">2022-02-09</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、为啥要用vscode调试运行在qemu上的代码？"><a href="#1、为啥要用vscode调试运行在qemu上的代码？" class="headerlink" title="1、为啥要用vscode调试运行在qemu上的代码？"></a>1、为啥要用vscode调试运行在qemu上的代码？</h3><p>最近的bootrom项目中，可以直接用python脚本一键启动，非常方便，结果也一目了然。但test case出现问题时不容易定位，使用gdb单步调试也不方便。</p>
<p>vscode可以打断点运行到有问题的代码处，但想要在vscode中debug跑在qemu上的代码，需要进行一系列的配置。</p>
<p>通过vscode打开要调试的代码工程，一般会有一个.vscode目录，内有两个文件分别是launch.json和tasks.json，就是通过这两个文件来完成调试配置。</p>
<h3 id="2、配置launch-json"><a href="#2、配置launch-json" class="headerlink" title="2、配置launch.json"></a>2、配置launch.json</h3><p>一般情况下，打开该文件都有一个模板，只需要根据自身需求，改动相应的参数即可。</p>
<p><strong>具体参数解释如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;qemu&amp;ctest--debug&quot;</span>, 	<span class="comment">//debug的名字，无所谓随便起。</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,				<span class="comment">//你要debug的代码类型，一般c/c++ 就用这个默认的就行</span></span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,			<span class="comment">//这个也是默认的，不用管</span></span><br><span class="line">            								<span class="comment">// qemu的开启服务，的调试地址，如果要调试运行在qemu上的代码，这个必不可少。</span></span><br><span class="line">            <span class="string">&quot;miDebuggerServerAddress&quot;</span>: <span class="string">&quot;127.0.0.1:1234&quot;</span>, </span><br><span class="line">           								 	<span class="comment">//你要调试的elf文件路径（推荐用绝对路径，不费脑子）</span></span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;/home/e0005105/w2030/bootrom/build/qemu_build/btr_test.elf&quot;</span>, </span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],						<span class="comment">//参数输入，可通过此处向main函数传参</span></span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,			<span class="comment">// 选为true则会在打开控制台后停滞，暂时不执行程序，看个人需求</span></span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,	<span class="comment">// 当前工作路径：当前文件所在的工作空间</span></span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,		<span class="comment">// 是否使用外部控制台</span></span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            								<span class="comment">// 设置riscv的调试gdb环境</span></span><br><span class="line">            <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/home/e0005105/w2030/toolchain/bin/riscv64-unknown-elf-gdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;logging&quot;</span>: &#123;					<span class="comment">// 日志打印</span></span><br><span class="line">                <span class="string">&quot;engineLogging&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、配置tasks-json"><a href="#3、配置tasks-json" class="headerlink" title="3、配置tasks.json"></a>3、配置tasks.json</h3><p>launch.json负责启动，而tasks.json则负责编译，能在终端执行的命令在这里也能执行。</p>
<p>为啥叫tasks就是因为能配置多个task。下面这个json文件中我配置了三个task，分别是:</p>
<p>​    <strong>1、qemu remake     2、qemu rebuild     3、start qemu</strong></p>
<p>通过control+shift+p打开命令窗口，选择要运行的任务，再选择要执行的子任务，回车即可执行。</p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202202091544656.png" alt="image-20220209154359604"></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202202091544132.png" alt="image-20220209154423104"></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202202091544195.png" alt="image-20220209154458160"></p>
<p><strong>具体参数解释如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,			<span class="comment">//要执行的命令类型 终端执行的一般为shell命令，类型选错则无法识别。</span></span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;qemu remake&quot;</span>,		<span class="comment">//子任务名称，随意取。</span></span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;python3 tool/bootromBuildTest.py --remake btr2qemu&quot;</span>,<span class="comment">//要执行的命令</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;qemu rebuild&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;python3 tool/bootromBuildTest.py --rebuild btr2qemu&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;start qemu&quot;</span>,</span><br><span class="line">            <span class="comment">//命令太长的话也可以通过args参数的形式进行分割，以要输入的命令中空格作为分隔符，写入args参数中，相对美观。</span></span><br><span class="line">            <span class="comment">//如果不进行分割，则command整体命令为(非常冗余)：</span></span><br><span class="line">            <span class="comment">// &quot;home/e0005105/w2030/qemu/build/riscv32-softmmu/qemu-system-riscv32 -nographic -machine sifive_e -kernel         			//  /home/e0005105/w2030/bootrom/build/qemu_build/btr_test.elf -s -S &quot;</span></span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;/home/e0005105/w2030/qemu/build/riscv32-softmmu/qemu-system-riscv32&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-nographic&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-machine&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sifive_e&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-kernel&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/home/e0005105/w2030/bootrom/build/qemu_build/btr_test.elf&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-s&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-S&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2022/01/20/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2022/01/20/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux 常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-20 20:04:58" itemprop="dateCreated datePublished" datetime="2022-01-20T20:04:58+08:00">2022-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-09 15:13:23" itemprop="dateModified" datetime="2022-02-09T15:13:23+08:00">2022-02-09</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>228</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="1、grep"><a href="#1、grep" class="headerlink" title="1、grep"></a>1、grep</h5><p><code>grep -rn “name” ./</code></p>
<p>在当前目录下递归查询包含字符串name的文件</p>
<h5 id="2、cp"><a href="#2、cp" class="headerlink" title="2、cp"></a>2、cp</h5><p><code>cp file1 file2</code></p>
<p>复制file的内容到file2中，如果file2已经存在，file2的内容会被file1覆盖。如果，file2不存在，则会创建file2</p>
<p><code>cp file1 file2  dir1</code></p>
<p>复制file1和file2到目录dir1，前提是dir1必须存在</p>
<h5 id="3、cat"><a href="#3、cat" class="headerlink" title="3、cat"></a>3、cat</h5><p><code>cat 1.txt     2.txt    3.txt &gt; 4.txt</code></p>
<p>将前三个文件的内容全部复制到第四个文件中去</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2022/01/06/AES%E5%92%8CSM4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2022/01/06/AES%E5%92%8CSM4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">AES和SM4加密算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-06 15:54:02 / 修改时间：16:56:25" itemprop="dateCreated datePublished" datetime="2022-01-06T15:54:02+08:00">2022-01-06</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、AES算法简介"><a href="#1、AES算法简介" class="headerlink" title="1、AES算法简介"></a>1、AES算法简介</h3><p><strong>高级加密标准*(AES,Advanced Encryption Standard)*为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</strong></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202201061611682.png" alt="img"></p>
<h3 id="2、AES的基本结构"><a href="#2、AES的基本结构" class="headerlink" title="2、AES的基本结构"></a>2、AES的基本结构</h3><p><strong>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：</strong></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202201061613312.png" alt="image-20220106161301258"></p>
<h3 id="3、AES的代码实现"><a href="#3、AES的代码实现" class="headerlink" title="3、AES的代码实现"></a>3、AES的代码实现</h3><h4 id="3-1-AES加密"><a href="#3-1-AES加密" class="headerlink" title="3.1 AES加密"></a>3.1 AES加密</h4><p>​    <strong>其中，<em>BinFilePath</em>位要加密的明文文件路径，<em>EncryFilePath</em>为加密后密文的输出路径。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ivec[EVP_MAX_IV_LENGTH] =	<span class="comment">//AES中的IV只能为一个16字节的byte[]ivec的内容可以任意指定，但是加密和解密操作必须使用同样的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAB</span>, <span class="number">0xCD</span>, <span class="number">0xEF</span>,</span><br><span class="line">    <span class="number">0xFE</span>, <span class="number">0xDC</span>, <span class="number">0xBA</span>, <span class="number">0x98</span>, <span class="number">0x76</span>, <span class="number">0x54</span>, <span class="number">0x32</span>, <span class="number">0x10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>] = <span class="comment">///&lt; key_data, 密钥内容, 至少16字节 由所选加密模式决定，我用的ecb_128故16字节</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xAB</span>, <span class="number">0xCD</span>, <span class="number">0xEF</span>,</span><br><span class="line">    <span class="number">0xFE</span>, <span class="number">0xDC</span>, <span class="number">0xBA</span>, <span class="number">0x98</span>, <span class="number">0x76</span>, <span class="number">0x54</span>, <span class="number">0x32</span>, <span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::AESEncrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* BinFilePath, <span class="keyword">const</span> <span class="keyword">char</span>* EncryFilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> indata[AES_BLOCK_SIZE];	<span class="comment">//AES_BLOCK_SIZE=16  存放每次读取的明文</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> outdata[AES_BLOCK_SIZE];	<span class="comment">//存放加密后的密文</span></span><br><span class="line"></span><br><span class="line">    FILE* fw, *fr;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, len=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fr = <span class="built_in">fopen</span>(BinFilePath, <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">    fw = <span class="built_in">fopen</span> (EncryFilePath, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    <span class="keyword">size_t</span> bytes_read, bytes_write;</span><br><span class="line"></span><br><span class="line">    EVP_CIPHER_CTX* ctx;</span><br><span class="line">    <span class="keyword">if</span> (!(ctx = <span class="built_in">EVP_CIPHER_CTX_new</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//EVP_aes_128_cbc()选择加密模式为aes_128bit模式</span></span><br><span class="line">    <span class="keyword">if</span> (!(ret= <span class="built_in">EVP_EncryptInit_ex</span>(ctx, <span class="built_in">EVP_aes_128_cbc</span>(), <span class="literal">NULL</span>, key, ivec))) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line">    ret=<span class="built_in">EVP_CIPHER_CTX_set_padding</span>(ctx, EVP_PADDING_ZERO); <span class="comment">//设置填充模式 </span></span><br><span class="line">    <span class="comment">//可以设置在加密数据时对不够长的数据进行填充的方式，pad可以设置为以下几个:</span></span><br><span class="line">    <span class="comment">//in file openssl/evp.h</span></span><br><span class="line">    <span class="comment">//#define EVP_PADDING_PKCS7       1</span></span><br><span class="line">    <span class="comment">//#define EVP_PADDING_ISO7816_4   2</span></span><br><span class="line">    <span class="comment">//#define EVP_PADDING_ANSI923     3</span></span><br><span class="line">    <span class="comment">//#define EVP_PADDING_ISO10126    4</span></span><br><span class="line">    <span class="comment">//#define EVP_PADDING_ZERO        5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes_read = <span class="built_in">fread</span>(indata, <span class="number">1</span>, <span class="number">16</span>, fr); <span class="comment">//每次加密数据16个字节 加密后密文也是16字节</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt; <span class="number">16</span>)	<span class="comment">//读取文件中数据最后不足16字节时，需要进行填充，</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">EVP_EncryptUpdate</span>(ctx, outdata, &amp;len, indata,(<span class="keyword">int</span>)bytes_read); <span class="comment">//len为加密后的密文长度返回值</span></span><br><span class="line">            ret = <span class="built_in">EVP_EncryptFinal_ex</span>(ctx, outdata + len, &amp;len);</span><br><span class="line">            bytes_write = <span class="built_in">fwrite</span>(outdata, <span class="number">1</span>, len, fw); <span class="comment">//将每次加密后的密文写入文件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">EVP_EncryptUpdate</span>(ctx, outdata, &amp;len, indata,(<span class="keyword">int</span>)bytes_read); <span class="comment">//每次读取16字节明文并返回16字节的密文</span></span><br><span class="line">            bytes_write = <span class="built_in">fwrite</span>(outdata, <span class="number">1</span>, len, fw);<span class="comment">//将每次加密后的密文写入文件</span></span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(outdata, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(outdata));</span><br><span class="line">        <span class="built_in">memset</span>(indata, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(indata));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVP_CIPHER_CTX_free</span>(ctx);</span><br><span class="line">    <span class="built_in">fclose</span>(fr);</span><br><span class="line">    <span class="built_in">fclose</span>(fw);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-AES解密"><a href="#3-2-AES解密" class="headerlink" title="3.2 AES解密"></a>3.2 AES解密</h4><p>​    <strong>其中，<em>EncryFilePath</em>为AES所加密的密文文件路径，<em>DecryFilePath</em>为存放解密后的明文文件路径，其余变量和函数基本与上面AES加密相对应。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::AESDecrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* EncryFilePath, <span class="keyword">const</span> <span class="keyword">char</span>* DecryFilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> indata[AES_BLOCK_SIZE];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> outdata[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">    FILE* fw, * fr;</span><br><span class="line">    fr = <span class="built_in">fopen</span>(EncryFilePath, <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">    fw = <span class="built_in">fopen</span>(DecryFilePath, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    <span class="keyword">size_t</span> bytes_read, bytes_write;</span><br><span class="line">    EVP_CIPHER_CTX* ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(ctx = <span class="built_in">EVP_CIPHER_CTX_new</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(ret= <span class="built_in">EVP_DecryptInit_ex</span>(ctx, <span class="built_in">EVP_aes_128_cbc</span>(), <span class="literal">NULL</span>, key, ivec)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret=<span class="built_in">EVP_CIPHER_CTX_set_padding</span>(ctx, EVP_PADDING_ZERO);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes_read = <span class="built_in">fread</span>(indata, <span class="number">1</span>, <span class="number">16</span>, fr);</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt; <span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">EVP_DecryptUpdate</span>(ctx, outdata, &amp;len, indata, (<span class="keyword">int</span>)bytes_read);</span><br><span class="line">            ret = <span class="built_in">EVP_DecryptFinal_ex</span>(ctx, outdata + len, &amp;len);</span><br><span class="line">            bytes_write = <span class="built_in">fwrite</span>(outdata, <span class="number">1</span>, len, fw);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">EVP_DecryptUpdate</span>(ctx, outdata, &amp;len, indata, (<span class="keyword">int</span>)bytes_read);</span><br><span class="line">            bytes_write = <span class="built_in">fwrite</span>(outdata, <span class="number">1</span>, len, fw);</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(outdata, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(outdata));</span><br><span class="line">        <span class="built_in">memset</span>(indata, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(indata));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(fr);</span><br><span class="line">    <span class="built_in">fclose</span>(fw);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、SM4加密和解密"><a href="#4、SM4加密和解密" class="headerlink" title="4、SM4加密和解密"></a>4、SM4加密和解密</h3><p>​    <strong>与DES和AES算法相似，国密SM4算法是一种分组加密算法。其分组长度和密钥长度均为128bits。</strong></p>
<p>​    <strong>SM4每次加密的明文为16个字节，输出的密文也为16个字节。</strong></p>
<p>​    <strong>SM4加密和解密过程基本与上面AES一致，只需将函数<code>EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, ivec)</code>中    <code>EVP_aes_128_cbc</code>替换    为<code>EVP_sm4_cbc</code>选择sm4加密模式即可。key和iv可以自行定义，但都得是16个字节。</strong></p>
<p><em><strong>问题遗留：</strong></em></p>
<p><strong>上面解密过程中数组<code>indata</code>为16字节大小，而<code>outdata</code>为32字节大小。</strong></p>
<p><strong>因为在<code>debug</code>过程中，观察内存发现，加密时读取16字节的明文，加密的密文也是16字节，而解密时读取16字节的密文，解密后却得到32字节的明文，如果<code>outdata</code>数组还是16字节大小，会发生数组越界错误。至于为什么这样，目前没搞明白，但将<code>outdata</code>数组尽量设置的大点，可以避免该错误</strong>。</p>
<p><strong>上述代码均通过加解密文件验证。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2021/12/31/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2021/12/31/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">RSA加密算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-31 16:42:34 / 修改时间：17:37:19" itemprop="dateCreated datePublished" datetime="2021-12-31T16:42:34+08:00">2021-12-31</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、RSA加密简介"><a href="#1、RSA加密简介" class="headerlink" title="1、RSA加密简介"></a>1、RSA加密简介</h3><p>​    <strong>RSA是由<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9">罗纳德·李维斯特</a>（Ron Rivest）、<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E9%98%BF%E8%BF%AA%C2%B7%E8%90%A8%E8%8E%AB%E5%B0%94">阿迪·萨莫尔</a>（Adi Shamir）和<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E4%BC%A6%E7%BA%B3%E5%BE%B7%C2%B7%E9%98%BF%E5%BE%B7%E6%9B%BC">伦纳德·阿德曼</a>（Leonard Adleman）在1977年一起提出的.PSA对极大整数做<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3">因数分解</a>的难度决定了 RSA 算法的可靠性。</strong></p>
<p>​    <strong>RSA是目前应用最广泛地一种非对称秘码体制。</strong></p>
<h3 id="2、生成RSA公钥和私钥"><a href="#2、生成RSA公钥和私钥" class="headerlink" title="2、生成RSA公钥和私钥"></a>2、生成RSA公钥和私钥</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::RsaKeyPairGen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">RSA_KEY_FREE</span>(rsa);</span><br><span class="line">	<span class="keyword">if</span> (!(Ret = <span class="built_in">RSA_generate_key_ex</span>(rsa, <span class="number">2048</span>, bne, <span class="literal">NULL</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RSA_KEY_FREE</span>(rsa);</span><br><span class="line">        <span class="keyword">return</span> ERR_GENERATE_KEY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FILE* Fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!rsa || !RSAPriKeyFileName) <span class="comment">//RSAPriKeyFileName为保存rsa私钥的文件路径</span></span><br><span class="line">        <span class="keyword">return</span> ERR_ARGUMENT;</span><br><span class="line">    <span class="keyword">if</span> (!(Fp = <span class="built_in">fopen</span>(RSAPriKeyFileName, <span class="string">&quot;wb&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_OPENFILE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PEM_write_RSAPrivateKey</span>(Fp, rsa, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) <span class="comment">//写入私钥</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(Fp);</span><br><span class="line">        <span class="keyword">return</span> ERR_WRITEPRIVATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(Fp);</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (!rsa || !RSAPubKeyFileName)</span><br><span class="line">        <span class="keyword">return</span> ERR_ARGUMENT;</span><br><span class="line">    <span class="keyword">if</span> (!(Fp = <span class="built_in">fopen</span>(RSAPubKeyFileName, <span class="string">&quot;wb&quot;</span>))) <span class="comment">//RSAPubKeyFileName为保存rsa私钥的文件路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_OPENFILE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PEM_write_RSA_PUBKEY</span>(Fp, rsa))  <span class="comment">//写入公钥</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(Fp);</span><br><span class="line">        <span class="keyword">return</span> ERR_WRITEPUBLIC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(Fp);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、通过RSA私钥进行签名"><a href="#3、通过RSA私钥进行签名" class="headerlink" title="3、通过RSA私钥进行签名"></a>3、通过RSA私钥进行签名</h3><p><strong>其中，from为要进行加密的数据，flen为数据长度，EncryptedStr指向加密后的数据，EncryptedLen为加密后数据长度。</strong></p>
<p><strong><em>RSA_PKCS1_PADDING</em>为填充模式，有好几种。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::PrivateKeyEncrypt</span><span class="params">(<span class="keyword">uint8_t</span>* from, <span class="keyword">int</span> flen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//---------------从文件中读取私钥并生成rsa------------------------------</span></span><br><span class="line">    ENGINE* e = <span class="literal">NULL</span>;</span><br><span class="line">    EVP_PKEY* pkey = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> pad;</span><br><span class="line">    <span class="keyword">if</span> (!bio_err) bio_err = <span class="built_in">BIO_new_fp</span>(stderr, BIO_NOCLOSE);</span><br><span class="line">    <span class="built_in">ERR_load_crypto_strings</span>();</span><br><span class="line">    <span class="built_in">OpenSSL_add_all_algorithms</span>();</span><br><span class="line">    pad = RSA_PKCS1_PADDING;</span><br><span class="line">    <span class="keyword">if</span> (!(pkey = <span class="built_in">load_key</span>(bio_err, RSAPriKeyFileName, FORMAT_PEM, <span class="number">0</span>,</span><br><span class="line">        PassWord, e, <span class="string">&quot;Private Key&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_OPENFILE;</span><br><span class="line">    &#125;</span><br><span class="line">    rsa = <span class="built_in">EVP_PKEY_get1_RSA</span>(pkey);</span><br><span class="line">    <span class="built_in">EVP_PKEY_free</span>(pkey);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//---------------RSA加密------------------------------</span></span><br><span class="line">    <span class="comment">//RSA_print_fp(stdout, rsa, 11);</span></span><br><span class="line">    <span class="keyword">int</span> Ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)(EncryptedLen = <span class="built_in">RSA_private_encrypt</span>(flen, from, EncryptedStr, rsa, RSA_PKCS1_PADDING)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Ret = ERR_PRIVATE_ENCRYPT;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Failed:</span><br><span class="line">    EncryptedLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、通过RSA公钥进行验签"><a href="#4、通过RSA公钥进行验签" class="headerlink" title="4、通过RSA公钥进行验签"></a>4、通过RSA公钥进行验签</h3><p><strong>其中，from为rsa加密后的数据，flen为数据长度，DecryptedStr指向解密后的数据，DecryptedLen为解密后数据长度。可以通过对比内存中DecryptedStr所指数据与上面步骤3中加密前的数据是否一致来判断解密是否成功</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::PublicKeyDecrypt</span><span class="params">(<span class="keyword">uint8_t</span>* from, <span class="keyword">int</span> flen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> Size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!rsa)</span><br><span class="line">        <span class="keyword">return</span> ERR_ARGUMENT;</span><br><span class="line">    Size = <span class="built_in">RSA_size</span>(rsa);</span><br><span class="line">    <span class="keyword">if</span> ((DecryptedLen = <span class="built_in">RSA_public_decrypt</span>(flen, from, DecryptedStr, rsa, RSA_PKCS1_PADDING)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RSA_public_decrypt\r\n&quot;</span>);</span><br><span class="line">        Ret = ERR_DECRYPT;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Failed:</span><br><span class="line">    EncryptedLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、RSA加密解密的三种填充模式"><a href="#5、RSA加密解密的三种填充模式" class="headerlink" title="5、RSA加密解密的三种填充模式"></a>5、RSA加密解密的三种填充模式</h3><p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112311731510.png" alt="image-20211231173137396"></p>
<h5 id="其中，本代码中采用用RSA-PKCS1-PADDING填充模式"><a href="#其中，本代码中采用用RSA-PKCS1-PADDING填充模式" class="headerlink" title="其中，本代码中采用用RSA_PKCS1_PADDING填充模式"></a>其中，本代码中采用用RSA_PKCS1_PADDING填充模式</h5><p>​        <strong>此填充模式是最常用的填充模式，在此填充模式下输入的长度受加密钥的长度限制，输入的最大长度为加密钥的位数k-11。如果公钥的长度为1024位即128字节，那么输入的长度最多为128-11=117字节。如果长度小于117就需要填充。如果输入T的长度为55字节，填充后的块为EM，则EM格式如下：</strong></p>
<ul>
<li><p>​                                                        <strong>EM= 0x00 || BT || PS || 0x00 || T</strong></p>
<p><strong>· 首字节填充0x00，确保加密块的大小小于加密钥（可见第四部分加密要求）</strong></p>
<p><strong>· BT仅一个字节，并只有三种选项0x00，0x01，0x02。其中0x02表示公钥加密，0x00，0x01表示私钥加密</strong></p>
<p><strong>· PS表示填充字段，根据BT类型有不同的情况。1.对于公钥加密的情况（即BT=0x02），PS为随机生成的且不含0的数。2.BT=0x00，PS填充的值为0x00（只有输入T不以0x00开头时，BT才为0x00，否则会有歧义）。3.BT=0x01，PS填充0xFF。PS的长度为128-3-len(T)=70字节，所以PS随机数长度至少为8个字节</strong></p>
<p><strong>· 而后填充0x00用于区分填充字段和输入信息</strong></p>
<p><strong>· T为实际的输入</strong></p>
</li>
</ul>
<p><strong>其余两种填充方式可查看其他博客中对填充模式的讲解（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0fc6631500e3">https://www.jianshu.com/p/0fc6631500e3</a>）</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2021/12/31/ECDSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2021/12/31/ECDSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">ECDSA加密算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-31 16:42:15" itemprop="dateCreated datePublished" datetime="2021-12-31T16:42:15+08:00">2021-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-18 10:39:21" itemprop="dateModified" datetime="2022-01-18T10:39:21+08:00">2022-01-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、ECDSA简述"><a href="#1、ECDSA简述" class="headerlink" title="1、ECDSA简述"></a>1、ECDSA简述</h3><p><strong>ECDSA的全名是Elliptic Curve DSA，即椭圆曲线DSA。它是Digital Signature Algorithm (DSA)应用了椭圆曲线加密算法的变种。椭圆曲线算法的原理很复杂，但是具有很好的公开密钥算法特性，通过公钥无法逆向获得私钥。</strong></p>
<p><strong>ECDSA算法用于数字签名，是ECC与DSA的结合，整个签名过程与DSA类似，所不一样的是签名中采取的算法为ECC，最后签名出来的值也是分为r,s。</strong></p>
<p><strong>ECC是建立在基于椭圆曲线的离散对数问题上的密码体制，给定椭圆曲线上的一个点G，并选取一个整数k，求解K=kG很容易(注意根据kG求解出来的K也是椭圆曲线上的一个点)；反过来，在椭圆曲线上给定两个点K和G，若使K=kG，求整数k是一个难题。ECC就是建立在此数学难题之上,这一数学难题称为椭圆曲线离散对数问题。其中椭圆曲线上的点K则为公钥(注意公钥K不是一个整数而是一个椭圆曲线点，这个点在OpenSSL里面是用结构体EC_Point来表示的，整数k则为私钥(实际上是一个大整数)。</strong></p>
<p><strong>签名过程如下：</strong></p>
<p>  1、选择一条椭圆曲线Ep(a,b)，和基点G；</p>
<p>  2、选择私有密钥k（k&lt;n，n为G的阶），利用基点G计算公开密钥K=kG；</p>
<p>  3、产生一个随机整数r（r&lt;n），计算点R=rG；</p>
<p>  4、将原数据和点R的坐标值x,y作为参数，计算SHA256做为hash，即Hash=SHA1(原数据,x,y)；</p>
<p>  5、计算s≡r - Hash * k (mod n)</p>
<p>  6、r和s做为签名值，如果r和s其中一个为0，重新从第3步开始执行</p>
<p><strong>验证过程如下：</strong></p>
<p>  1、接受方在收到消息(m)和签名值(r,s)后，进行以下运算</p>
<p>  2、计算：sG+H(m)P=(x1,y1), r1≡ x1 mod p。</p>
<p>  3、验证等式：r1 ≡ r mod p。</p>
<p>  4、如果等式成立，接受签名，否则签名无效。</p>
<h3 id="2、生成ECDSA公钥和私钥"><a href="#2、生成ECDSA公钥和私钥" class="headerlink" title="2、生成ECDSA公钥和私钥"></a>2、生成ECDSA公钥和私钥</h3><p><strong>其中，ECDSAPriKeyFileName、ECDSAPubKeyFileName为要保存公钥和私钥的文件路径。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::CreateECDSAKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Ret = <span class="number">0</span>;</span><br><span class="line">    EC_KEY* ec_key = <span class="literal">NULL</span>;    <span class="comment">//椭圆曲线的参数、私钥和公钥都保存在这个结构中。</span></span><br><span class="line">    EC_GROUP* ec_group;		<span class="comment">//这个结构体保存着椭圆曲线的参数</span></span><br><span class="line"></span><br><span class="line">    ec_key = <span class="built_in">EC_KEY_new</span>();<span class="comment">//通过调用EC_KEY_new（）来构造没有关联曲线的新EC_KEY。</span></span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">    <span class="keyword">if</span> (!ec_key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error：ec_key is err!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ec_group = <span class="built_in">EC_GROUP_new_by_curve_name</span>(NID_secp256k1);  <span class="comment">//根据指定的椭圆曲线来生成密钥参数。</span></span><br><span class="line">    <span class="keyword">if</span> (!ec_group)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error：ec_group is err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//asn1_标志值用于确定曲线编码是使用显式参数还是使用asn1 OID的命名曲线：许多应用程序仅支持后一种形式。</span></span><br><span class="line">    <span class="built_in">EC_GROUP_set_asn1_flag</span>(ec_group, OPENSSL_EC_NAMED_CURVE);</span><br><span class="line">    <span class="comment">//如果asn1_标志为OPENSSL_EC_NAMED_CURVE，则使用命名曲线形式，并且参数必须具有相应的命名曲线NID集</span></span><br><span class="line">    <span class="built_in">EC_GROUP_set_point_conversion_form</span>(ec_group, POINT_CONVERSION_UNCOMPRESSED);<span class="comment">//获取曲线的点转换形式。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != <span class="built_in">EC_KEY_set_group</span>(ec_key, ec_group))<span class="comment">//将EC_GROUP结构体的内容填充到EC_KEY中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error：EC_KEY_set_group err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//EC_KEY_generate_KEY（）为提供的eckey对象生成新的公钥和私钥。在调用此函数之前，eckey必须有一个与之关联的EC_组对象.</span></span><br><span class="line">    <span class="comment">//私钥是一个随机整数（0&lt;priv_key&lt;order，其中order是EC_组对象的顺序）。公钥是曲线上的一个EC_点，通过曲线生成器乘以私钥计算得出。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EC_KEY_generate_key</span>(ec_key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error：EC_KEY_generate_key()  err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存公钥</span></span><br><span class="line">    <span class="keyword">if</span> (!ECDSAPubKeyFileName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Cannot open file %s\r\n&quot;</span>, ECDSAPubKeyFileName);</span><br><span class="line">        <span class="keyword">return</span> ERR_OPENFILE;</span><br><span class="line">    &#125;</span><br><span class="line">    Ret = <span class="built_in">WritePublicKeyToFile</span>(ECDSAPubKeyFileName, ec_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存私钥</span></span><br><span class="line">    <span class="keyword">if</span> (!ECDSAPriKeyFileName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Cannot open file %s\r\n&quot;</span>, ECDSAPriKeyFileName);</span><br><span class="line">        <span class="keyword">return</span> ERR_OPENFILE;</span><br><span class="line">    &#125;</span><br><span class="line">    Ret = <span class="built_in">WritePrivateKeyToFile</span>(ECDSAPriKeyFileName, ec_key, ec_group);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ec_key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">EC_KEY_free</span>(ec_key);</span><br><span class="line">        ec_key = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::WritePublicKeyToFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Path, EC_KEY* pKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Ret = <span class="number">0</span>;</span><br><span class="line">    BIO* pBioFile = <span class="built_in">BIO_new_file</span>(Path, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pBioFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error：pBioFile err \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != <span class="built_in">PEM_write_bio_EC_PUBKEY</span>(pBioFile, pKey))  <span class="comment">//写入公钥</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error：PEM_write_bio_EC_PUBKEY err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Ret = ECDSA_SUCESS;</span><br><span class="line">    <span class="built_in">BIO_free</span>(pBioFile);</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::WritePrivateKeyToFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Path, EC_KEY* pKey, EC_GROUP* ec_group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Ret = <span class="number">0</span>;</span><br><span class="line">    BIO* pBioFile = <span class="built_in">BIO_new_file</span>(Path, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pBioFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error：pBioFile err \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PEM_write_bio_ECPKParameters</span>(pBioFile, ec_group);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != <span class="built_in">PEM_write_bio_ECPrivateKey</span>(pBioFile, pKey, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>))  <span class="comment">//写入私钥</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error：PEM_write_bio_ECPrivateKey err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ret = ECDSA_SUCESS;</span><br><span class="line">    <span class="built_in">BIO_free</span>(pBioFile);</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">BEGIN</span> <span class="comment">EC</span> <span class="comment">PARAMETERS</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">BgUrgQQACg==</span>              </span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">END</span> <span class="comment">EC</span> <span class="comment">PARAMETERS</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">BEGIN</span> <span class="comment">EC</span> <span class="comment">PRIVATE</span> <span class="comment">KEY</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">MHQCAQEEIAEDdomPvSs/hjUobObUr5Kq4xfjcKDn</span><span class="literal">+</span><span class="comment">QV1ExnIsyPQoAcGBSuBBAAK</span></span><br><span class="line"><span class="comment">oUQDQgAEkHwZd/CTpWrcfuvXGbHDZbyfPna1hiAQlEsiSIaVTFu99IEwcTginJiM</span></span><br><span class="line"><span class="comment">9TEJrYJ5LODD4znP9kVDuRbcZaguaQ==</span></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">END</span> <span class="comment">EC</span> <span class="comment">PRIVATE</span> <span class="comment">KEY</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>*BgUrgQQACg==*</code>  是椭圆曲线的关键参数，对应<code>secp256k1</code>标识。</p>
<p>用<code>secp256k1</code>生成私钥每次私钥是不同的，但<code>EC PARAMETERS</code>都是相同的。</p>
<p>只有用不同的name指定不同曲线<code>EC PARAMETERS</code>才会不同。</p>
<h4 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN <span class="keyword">PUBLIC</span> <span class="keyword">KEY</span>-----</span><br><span class="line">MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEkHwZd/CTpWrcfuvXGbHDZbyfPna1hiAQ</span><br><span class="line">lEsiSIaVTFu99IEwcTginJiM9TEJrYJ5LODD4znP9kVDuRbcZaguaQ==</span><br><span class="line">-----<span class="keyword">END</span> <span class="keyword">PUBLIC</span> <span class="keyword">KEY</span>-----</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>生成的是非压缩格式的公钥。</strong></p>
<h4 id="密钥数据结构"><a href="#密钥数据结构" class="headerlink" title="密钥数据结构"></a>密钥数据结构</h4><p>密钥数据结构定义在openssl-1.1.1\crypto\ec\ec_local.h文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ec_key_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> EC_KEY_METHOD *meth;</span><br><span class="line">    ENGINE *engine;</span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line">    EC_GROUP *group; <span class="comment">//密钥参数</span></span><br><span class="line">    EC_POINT *pub_key; <span class="comment">//公钥 是曲线上的一个点</span></span><br><span class="line">    BIGNUM *priv_key; <span class="comment">//私钥</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> enc_flag;</span><br><span class="line">    <span class="keyword">point_conversion_form_t</span> conv_form;</span><br><span class="line">    <span class="keyword">int</span> references;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    CRYPTO_EX_DATA ex_data;</span><br><span class="line">    CRYPTO_RWLOCK *lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>参数解释：</strong></p>
<p>1、 <code>EC_KEY_METHOD *meth;</code><br>在结构体<code>ec_method_st</code>中列举了实现过程中用到的各种椭圆曲线算法，比如椭圆曲线点群的建立和释放，设置群参数，点的比较，点的加法和倍乘等等，覆盖面很广，几乎涉及所有的椭圆曲线算法。<br>其主要作用在于能够将函数在素域和二元域的接口统一起来。举个例子，“判断点是否在曲线上”只需要调用<code>EC_POINT_is_on_curve</code>函数，而无需考虑是二元域还是素域。</p>
<p>2、<code>ENGINE *engine;</code></p>
<p><em><code>ENGINE</code><em>是</em><code>OPENSSL</code><em>预留的用以加载第三方加密库引擎，主要包括了动态库加载的代码和加密函数指针管理的一系列接口。如果要使用</em>Engine</em>，那么首先要加载该*<code>Engine</code>(<em>比如</em><code>ENGINE_load_XXXX</code>)<em>，然后选择要使用的算法或者使用支持的所有加密算法（有相关函数）。这样你的应用程序在调用加解密算法时，它就会指向你加载的动态库里的加解密算法，而不是原先的</em><code>OPENSSL</code>*的库里的加解密算法。</p>
<p>3、<code>EC_GROUP *group;</code> </p>
<p>椭圆曲线数据结构：<code>EC_GROUP</code>，该结构不仅包含各个参数，还包含了各种算法；根据密钥参数<code>group</code>来生公私钥。</p>
<p>对于<code>ECC</code>算法来说，仅仅知道公钥和私钥是不能调用<code>OpenSSL</code>自带的签名和验签API，还需要知道对应的椭圆曲线。<code>*BgUrgQQACg==*</code>  是椭圆曲线的关键参数，对应<code>secp256k1</code>标识。所生产得密钥中这参数便是用来确认椭圆曲线的。</p>
<p>4、<code>EC_POINT *pub_key;</code></p>
<p>EC_POINT，其中的大数X、Y和Z为雅克比投影坐标，向量；</p>
<p>5、<code>BIGNUM *priv_key;</code></p>
<p>私钥，为一个大数。</p>
<p>6、<code>unsigned int enc_flag;</code></p>
<p>当前定义了两个编码标志<code>EC_PKEY_NO_PARAMETERS</code>和<code>EC_PKEY_NO_PUBKEY</code>。这些标志定义了调用<code>i2d_ECPrivateKey（）</code>时如何将密钥转换为ASN1的行为。如果设置了<code>EC_PKEY_NO_PARAMETERS</code>，则曲线的公共参数不会与私钥一起编码。如果设置了<code>EC_PKEY_NO_PUBKEY</code>，则公钥不会与私钥一起编码。</p>
<p>7、<code>point_conversion_form_t conv_form;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Enum for the point conversion form as defined in X9.62 (ECDSA)</span></span><br><span class="line"><span class="comment"> *  for the encoding of a elliptic curve point (x,y) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        <span class="comment">/** the point is encoded as z||x, where the octet z specifies</span></span><br><span class="line"><span class="comment">         *  which solution of the quadratic equation y is  */</span></span><br><span class="line">    POINT_CONVERSION_COMPRESSED = <span class="number">2</span>,   <span class="comment">//表示采用点压缩。</span></span><br><span class="line">        <span class="comment">/** the point is encoded as z||x||y, where z is the octet 0x04  */</span></span><br><span class="line">    POINT_CONVERSION_UNCOMPRESSED = <span class="number">4</span>, 	<span class="comment">//表示不采用压缩</span></span><br><span class="line">        <span class="comment">/** the point is encoded as z||x||y, where the octet z specifies</span></span><br><span class="line"><span class="comment">         *  which solution of the quadratic equation y is  */</span></span><br><span class="line">    POINT_CONVERSION_HYBRID = <span class="number">6</span>			<span class="comment">//表示混合使用，即既包含点压缩又包含未压缩</span></span><br><span class="line">&#125; <span class="keyword">point_conversion_form_t</span>;</span><br></pre></td></tr></table></figure>

<p>8、<code>CRYPTO_EX_DATA ex_data;</code></p>
<p>额外的附加信息</p>
<p>9、<code>CRYPTO_RWLOCK *lock;</code></p>
<p>加密时候的线程锁</p>
<h3 id="3、通过ECDSA私钥进行签名"><a href="#3、通过ECDSA私钥进行签名" class="headerlink" title="3、通过ECDSA私钥进行签名"></a>3、通过ECDSA私钥进行签名</h3><p><strong>其中，hash、hashsize为其他算法（sha256/SM3）所生成的32位摘要。</strong></p>
<p><strong>使用256位EC密钥进行签名使用的是DER 编码模式，所以签名长度是不定的，在71 - 73 个字节之间</strong></p>
<p><strong>相关链接：</strong></p>
<p> <a target="_blank" rel="noopener" href="https://www.thinbug.com/q/17269238">https://www.thinbug.com/q/17269238</a></p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/1038">https://learnblockchain.cn/article/1038</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/422864492">https://zhuanlan.zhihu.com/p/422864492</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::ECDSAPrivkeySign</span><span class="params">(<span class="keyword">uint8_t</span>* hash_value, <span class="keyword">uint32_t</span> hash_size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* buffer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buf_len;</span><br><span class="line">    <span class="keyword">int</span> Ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//-------------ECDSA加密------------------------------</span></span><br><span class="line">    EC_KEY* ec_key;</span><br><span class="line">    BIO* pBioKeyFile;</span><br><span class="line">    pBioKeyFile = <span class="built_in">BIO_new_file</span>(ECDSAPriKeyFileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    ec_key = <span class="built_in">PEM_read_bio_ECPrivateKey</span>(pBioKeyFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">//读取私钥</span></span><br><span class="line">    <span class="keyword">if</span> (!ec_key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read ec_key err!\n&quot;</span>);</span><br><span class="line">        Ret = ERR_ECDSA;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line">    buf_len = <span class="built_in">ECDSA_size</span>(ec_key);<span class="comment">//获取ECC密钥大小字节数</span></span><br><span class="line">    buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(buf_len); <span class="comment">//分配内存，buffer用来保存签名后的数据</span></span><br><span class="line">    <span class="keyword">if</span> (!(Ret=<span class="built_in">ECDSA_sign</span>(<span class="number">0</span>, Hash, HashSize, buffer, &amp;buf_len, ec_key))) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ECDSA_sign is err!\n&quot;</span>);</span><br><span class="line">        Ret = ERR_ECDSA;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ec_key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">EC_KEY_free</span>(ec_key);</span><br><span class="line">        ec_key = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pBioKeyFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">BIO_free</span>(pBioKeyFile);</span><br><span class="line">        pBioKeyFile = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Failed:</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中，ECDSA_size函数用来获取ECC密钥的大小，后面生成的签名数据大小也是由他来决定。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ECDSA_size</span><span class="params">(<span class="keyword">const</span> EC_KEY *ec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ECDSA_SIG sig;</span><br><span class="line">    <span class="keyword">const</span> EC_GROUP *group;</span><br><span class="line">    <span class="keyword">const</span> BIGNUM *bn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ec == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    group = <span class="built_in">EC_KEY_get0_group</span>(ec);  <span class="comment">//获取EC_key中的曲线参数</span></span><br><span class="line">    <span class="keyword">if</span> (group == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bn = <span class="built_in">EC_GROUP_get0_order</span>(group); <span class="comment">//获取group的order，是一个大数，具体干啥的不知道</span></span><br><span class="line">    <span class="keyword">if</span> (bn == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sig.r = sig.s = (BIGNUM *)bn;  <span class="comment">//初始化sig.r和sig.s</span></span><br><span class="line">    ret = <span class="built_in">i2d_ECDSA_SIG</span>(&amp;sig, <span class="literal">NULL</span>); <span class="comment">//通过i2d_ECDSA_SIG函数对sig结构体进行编码为DER结构，返回值为其编码大小。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，<code>i2d_ECDSA_SIG</code>函数中有个关键函数：<code>ossl_encode_der_dsa_sig</code>该函数输出<code>ECDSA-Sig-Value</code>的DER编码至pkt，由pkt用来存储编码内容。</p>
<h4 id="签名值数据结构"><a href="#签名值数据结构" class="headerlink" title="签名值数据结构"></a>签名值数据结构</h4><p>ECDSA 的签名结果表示为两项。 ECDSA 的签名结果数据结构定义在 <code>crypto\ec\ec_lcl.h</code> 中。</p>
<p>一般情况，最后的结果<code>r</code>和<code>s</code>是用<code>asn1</code>格式的<code>DER</code>编码封装的，至少的<code>TLS</code>签名和数字证书签名中是这样的，不是简单的<code>r+s</code>这样字节直接拼接.</p>
<p>关于<code>der</code>编码方式可参见这边博客：<a target="_blank" rel="noopener" href="https://www.twblogs.net/a/5b7e3af92b71776838560af9/?lang=zh-cn">https://www.twblogs.net/a/5b7e3af92b71776838560af9/?lang=zh-cn</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ECDSA_SIG_st</span> &#123;</span></span><br><span class="line">    BIGNUM *r;</span><br><span class="line">    BIGNUM *s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里使用SM3或者SHA256得到数据摘要后进行签名，以下面一个签名为例讲解DER编码后的签名序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buffer=[<span class="number">3046022100</span>adf6eafb0a32f398a88819ee984333e4241764487bbb47e68adb0b6533d6454c022100a4d4e55e928f1ba32e53405dffb781ae0bccf2acb8c19a1095e440189c20d388]</span><br><span class="line"><span class="comment">// 0x30表示DER序列的开始</span></span><br><span class="line"><span class="comment">// 0x46 - 序列的长度（70字节）</span></span><br><span class="line"><span class="comment">// 0x02 - 一个整数值</span></span><br><span class="line"><span class="comment">// 0x21 - 整数的长度（33字节）</span></span><br><span class="line"><span class="comment">// R-00adf6eafb0a32f398a88819ee984333e4241764487bbb47e68adb0b6533d6454c</span></span><br><span class="line"><span class="comment">// 0x02 - 接下来是一个整数</span></span><br><span class="line"><span class="comment">// 0x21 - 整数的长度（33字节）</span></span><br><span class="line"><span class="comment">// S-00a4d4e55e928f1ba32e53405dffb781ae0bccf2acb8c19a1095e440189c20d388</span></span><br></pre></td></tr></table></figure>

<h3 id="4、通过ECDSA公钥验签"><a href="#4、通过ECDSA公钥验签" class="headerlink" title="4、通过ECDSA公钥验签"></a>4、通过ECDSA公钥验签</h3><p><strong>其中，hash、hashsize为其他算法（sha256/SM3）所生成的32位摘要。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::ECDSAPubkeyVerify</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> buf_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> Ret = <span class="number">0</span>;</span><br><span class="line">    EC_KEY* ec_key = <span class="literal">NULL</span>;</span><br><span class="line">    BIO* pBioKeyFile = <span class="literal">NULL</span>;</span><br><span class="line">    pBioKeyFile = <span class="built_in">BIO_new_file</span>(ECDSAPubKeyFileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    ec_key = <span class="built_in">PEM_read_bio_EC_PUBKEY</span>(pBioKeyFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//从pem文件中读取公钥</span></span><br><span class="line">    <span class="keyword">if</span> (!ec_key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read pubkey failed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Ret = <span class="built_in">ECDSA_verify</span>(<span class="number">0</span>, Hash, HashSize, buffer, buf_len, ec_key); <span class="comment">//buffer为加密后的数据，buf_len为加密数据长度一般为71</span></span><br><span class="line">    <span class="keyword">if</span> (Ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ECDSA_verify failed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pBioKeyFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">BIO_free</span>(pBioKeyFile);</span><br><span class="line">        pBioKeyFile = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ec_key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">EC_KEY_free</span>(ec_key);</span><br><span class="line">        ec_key = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2021/12/31/%E5%9B%BD%E5%AF%86SM3%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2021/12/31/%E5%9B%BD%E5%AF%86SM3%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">国密SM3摘要算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-31 15:40:29 / 修改时间：16:02:46" itemprop="dateCreated datePublished" datetime="2021-12-31T15:40:29+08:00">2021-12-31</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、什么是SM3算法？"><a href="#1、什么是SM3算法？" class="headerlink" title="1、什么是SM3算法？"></a>1、什么是SM3算法？</h3><p>​    <strong>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%95%86%E7%94%A8%E5%AF%86%E7%A0%81">商用密码</a>体系中，SM3主要用于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">数字签名</a>及验证、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81">消息认证码</a>生成及验证、随机数生成等，其算法公开。据国家密码管理局表示，其安全性及效率与SHA-256相当。</strong></p>
<h3 id="2、SM3算法实现（c-c-）"><a href="#2、SM3算法实现（c-c-）" class="headerlink" title="2、SM3算法实现（c/c++）"></a>2、SM3算法实现（c/c++）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeneratorRsaKey::SM3Checksum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Path, <span class="keyword">uint32_t</span>* FSize, <span class="keyword">uint8_t</span>* PSha256)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//其中 path为要进行hash的文件路径、fsize为文件数据大小、psha256为sm3算法生成的32位hash值</span></span><br><span class="line">    FILE* Fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> Len = <span class="number">0</span>, Count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> Buf[MAXTEMPBUF];</span><br><span class="line">    <span class="keyword">int</span> Ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_size;</span><br><span class="line">    *FSize = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">memset</span>(PSha256, <span class="number">0</span>, HASH_SM3_LEN);</span><br><span class="line">    EVP_MD_CTX* md_ctx;</span><br><span class="line">    <span class="keyword">const</span> EVP_MD* md;</span><br><span class="line"></span><br><span class="line">    md = <span class="built_in">EVP_sm3</span>();</span><br><span class="line">    md_ctx = <span class="built_in">EVP_MD_CTX_new</span>();</span><br><span class="line">    <span class="keyword">if</span> (!(Fp = <span class="built_in">fopen</span>(Path, <span class="string">&quot;rb&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_OPENFILE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EVP_DigestInit_ex</span>(md_ctx, md, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">feof</span>(Fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ferror</span>(Fp))</span><br><span class="line">        &#123;</span><br><span class="line">            Ret = ERR_IO;</span><br><span class="line">            <span class="keyword">goto</span> Failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((Len = (<span class="keyword">uint32_t</span>)<span class="built_in">fread</span>(Buf, <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Buf), Fp)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">EVP_DigestUpdate</span>(md_ctx, Buf, Len))</span><br><span class="line">        &#123;</span><br><span class="line">            Ret = ERR_HASH;</span><br><span class="line">            <span class="keyword">goto</span> Failed;</span><br><span class="line">        &#125;</span><br><span class="line">        Count += Len;</span><br><span class="line">    &#125;</span><br><span class="line">    *FSize = Count;</span><br><span class="line">    <span class="built_in">EVP_DigestFinal_ex</span>(md_ctx, PSha256, &amp;hash_size); <span class="comment">//hash_size不能为NULL，其值将为SM3算法所生成摘要数据的大小</span></span><br><span class="line"></span><br><span class="line">Failed:</span><br><span class="line">    <span class="built_in">EVP_MD_CTX_free</span>(md_ctx);</span><br><span class="line">    <span class="built_in">fclose</span>(Fp);</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2021/12/28/%E5%A6%82%E4%BD%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2021/12/28/%E5%A6%82%E4%BD%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">如何字符串直接写入内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-28 10:06:26" itemprop="dateCreated datePublished" datetime="2021-12-28T10:06:26+08:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-31 16:27:51" itemprop="dateModified" datetime="2021-12-31T16:27:51+08:00">2021-12-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>508</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="将字符串直接写入内存中"><a href="#将字符串直接写入内存中" class="headerlink" title="将字符串直接写入内存中"></a>将字符串直接写入内存中</h3><p>​    <strong>有时候我们想通过传参的形式将0x01这种16进制的数据直接写入内存，但ascii码对照表最大仅为0x7f，有些16进制数据如0xff无法通过字符的形式写入，可以试试下面这个函数。我们可以将想要写入内存的数据直接写为字符串形式，如我想往内存中写入：57 53 45 bb 。那么我们可以直接声明该字符串为 :</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * str=<span class="string">&quot;575345bb&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>在调用下面这个函数就能将该字符串直接写入内存中了，下面为该函数的实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetStrToMem</span><span class="params">(string str, <span class="keyword">char</span>* mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (string::size_type ix = <span class="number">0</span>; ix != str.<span class="built_in">size</span>(); ix = ix + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        basic_string &lt;<span class="keyword">char</span>&gt; tmp = str.<span class="built_in">substr</span>(ix, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> i = (<span class="keyword">char</span>)<span class="built_in">strtol</span>(tmp.<span class="built_in">c_str</span>(), &amp;s, <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(mem, &amp;i, <span class="number">1</span>);</span><br><span class="line">        mem++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中，str为想直接写入内存的数据，mem为要赋值的变量。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2021/12/24/%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2021/12/24/%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">调试代码过程中遇到的一些问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-24 15:45:29" itemprop="dateCreated datePublished" datetime="2021-12-24T15:45:29+08:00">2021-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-25 16:41:20" itemprop="dateModified" datetime="2022-01-25T16:41:20+08:00">2022-01-25</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1、fopen函数打开文件方式"><a href="#1、fopen函数打开文件方式" class="headerlink" title="1、fopen函数打开文件方式"></a>1、fopen函数打开文件方式</h4><p>fopen的rb打开模式，b表示以二进制方式打开，在进行二进制文件读写时，要采用此方式打开文件，否则fread函数在进行读字节时，会出现未知错误。</p>
<h4 id="2、fopen在linux中进行文件读写"><a href="#2、fopen在linux中进行文件读写" class="headerlink" title="2、fopen在linux中进行文件读写"></a>2、fopen在linux中进行文件读写</h4><p>fopen函数在Linux中打开文件时，一定要确认要是否有权限打开该文件，否则需要进行 <code>chmod 777 +文件名</code> 改变文件操作权限。</p>
<h4 id="3、关于报错：Run-Time-Check-Failure-2-Stack-around-the-variable-‘xxx’-was-corrupted的解决方式"><a href="#3、关于报错：Run-Time-Check-Failure-2-Stack-around-the-variable-‘xxx’-was-corrupted的解决方式" class="headerlink" title="3、关于报错：Run-Time Check Failure #2 - Stack around the variable ‘xxx’ was corrupted的解决方式"></a>3、关于报错：Run-Time Check Failure #2 - Stack around the variable ‘xxx’ was corrupted的解决方式</h4><p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112241611901.png" alt="image-20211224161104868"></p>
<p>这个报错字面意思是定义的变量xxx附近的内存被破坏了,在网上找到的解决方案共两种：</p>
<p>a、堆栈溢出、内存访问越界 </p>
<p>​    该方法需要仔细检查数组下标访问的合法性。在经过检查后发现并无这类问题，此方案并未解决问题。</p>
<p>b、将该局部变量设置为全局变量</p>
<p>​    采用该方法将bufer_hex由局部变量变为全局变量后，问题得到解决，但并未找到其问题根源所在。**</p>
<h4 id="4、c-中string转字符数组-坑1"><a href="#4、c-中string转字符数组-坑1" class="headerlink" title="4、c++中string转字符数组 坑1"></a>4、c++中string转字符数组 坑1</h4><p>​    最近在写一个功能是通过读取txt配置文件来设置一些代码参数配置。通过<code>getline</code>函数可以从文件中一行一行地读取数据，每行数据为一条参数信息，长度从几字节到几十字节不等。因此，需要通过c++中的string来进行接收不定长数据。原代码左值为<code>const char *</code> 类型，不能直接通过<code>string</code>进行赋值，因此需要将<code>string</code>转为<code>char</code>数组，问题也出在这里。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * ch;</span><br><span class="line">string str=<span class="string">&quot;1234&quot;</span>;</span><br><span class="line">ch=str.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>

<p>​    在拿到<code>string str</code>时，可以通过<code>str.c_str()</code>函数将字符串转为字符数组，返回一个指向字符数组的指针。如上所提，原代码左值为<code>const char*</code>类型，但却不能直接用指针<code>ch</code>作为右值进行赋值。因为<code>ch</code>指向的内容随着所在函数结束会进行析构，最后会变成垃圾，要想拿到其指向的数据并完成赋值，需要利用<code>strcpy</code>函数进行复制后再使用。</p>
<h4 id="5、c-中string转字符数组-坑2"><a href="#5、c-中string转字符数组-坑2" class="headerlink" title="5、c++中string转字符数组 坑2"></a>5、c++中string转字符数组 坑2</h4><p>字符串与数组的区别是末尾多个\0，而在调用str.length()函数计算其长度时则不会将\0计算在内。因此若要将其转为字符数组，所需内存空间为size+1；否则指针ch所指向的这块内存区域，在释放时会报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * ch;</span><br><span class="line">string str=<span class="string">&quot;1234&quot;</span>;</span><br><span class="line">ch=<span class="keyword">new</span> <span class="keyword">char</span> [str.<span class="built_in">length</span>()+<span class="number">1</span>]</span><br><span class="line"><span class="built_in">strcpy</span>(ch,str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<h4 id="6、c-中实现trim函数去除string字符串中的空格和tab"><a href="#6、c-中实现trim函数去除string字符串中的空格和tab" class="headerlink" title="6、c++中实现trim函数去除string字符串中的空格和tab"></a>6、c++中实现trim函数去除string字符串中的空格和tab</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> string <span class="title">trim</span><span class="params">(string &amp;s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> string&amp; delim = <span class="string">&quot; \t\r&quot;</span>;</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(delim));</span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(delim) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2021/12/21/linux%E5%B9%B3%E5%8F%B0openssl%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2021/12/21/linux%E5%B9%B3%E5%8F%B0openssl%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">linux平台下openssl编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-21 09:30:49" itemprop="dateCreated datePublished" datetime="2021-12-21T09:30:49+08:00">2021-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-31 15:44:36" itemprop="dateModified" datetime="2021-12-31T15:44:36+08:00">2021-12-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>325</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、下载openssl"><a href="#1、下载openssl" class="headerlink" title="1、下载openssl"></a>1、下载openssl</h3><p><a href=""><strong>openssl地址（https://github.com/openssl/openssl#download）</strong></a></p>
<p><strong>下载后文件中内容如下：</strong></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210925014.png" alt="image-20211221092545932"></p>
<h3 id="2、输入config命令"><a href="#2、输入config命令" class="headerlink" title="2、输入config命令"></a>2、输入config命令</h3><p> <code>**./config --prefix=/home/e0005105/openssl/openssl-linux--prefix=/home/e0005105/openssl/openssl-linux**</code> </p>
<p><strong>其中，=后面为你要生成编译文件的目录</strong></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210926629.png" alt="image-20211221092609433"></p>
<h3 id="3、执行make命令"><a href="#3、执行make命令" class="headerlink" title="3、执行make命令"></a>3、执行<code>make</code>命令</h3><h3 id="4、执行make-test命令（可选）"><a href="#4、执行make-test命令（可选）" class="headerlink" title="4、执行make test命令（可选）"></a>4、执行<code>make test</code>命令（可选）</h3><p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210931597.png" alt="image-20211221092700880"></p>
<h3 id="5、执行make-install-命令"><a href="#5、执行make-install-命令" class="headerlink" title="5、执行make install 命令"></a>5、执行<code>make install</code> 命令</h3><h3 id="6、-执行完成后切回前面所选安装的openssl-linux目录查看已经编译好的openssl文件"><a href="#6、-执行完成后切回前面所选安装的openssl-linux目录查看已经编译好的openssl文件" class="headerlink" title="6、 执行完成后切回前面所选安装的openssl-linux目录查看已经编译好的openssl文件"></a>6、 执行完成后切回前面所选安装的openssl-linux目录查看已经编译好的openssl文件</h3><p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210927708.png" alt="image-20211221092752608"></p>
<p>​    <strong>其中lib64目录下就是编译好的动态库和静态库</strong></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210931581.png" alt="image-20211221092841664"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liang-shenlin.gitee.io/blogger/2021/12/20/windows%E5%B9%B3%E5%8F%B0openssl%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogger/images/cafecat.png">
      <meta itemprop="name" content="梁申麟">
      <meta itemprop="description" content="吃好喝好，长生不老。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="E0005105">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogger/2021/12/20/windows%E5%B9%B3%E5%8F%B0openssl%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">window平台下openssl 编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-20 18:18:00" itemprop="dateCreated datePublished" datetime="2021-12-20T18:18:00+08:00">2021-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-31 15:44:45" itemprop="dateModified" datetime="2021-12-31T15:44:45+08:00">2021-12-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>720</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、-下载并安装perl（windows版本）"><a href="#1、-下载并安装perl（windows版本）" class="headerlink" title="1、    下载并安装perl（windows版本）"></a>1、    下载并安装perl（windows版本）</h2><h3 id="https-www-activestate-com-products-perl-downloads"><a href="#https-www-activestate-com-products-perl-downloads" class="headerlink" title="https://www.activestate.com/products/perl/downloads/"></a><a target="_blank" rel="noopener" href="https://www.activestate.com/products/perl/downloads/">https://www.activestate.com/products/perl/downloads/</a></h3><p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210900021.png"></p>
<h2 id="2、-配置环境变量"><a href="#2、-配置环境变量" class="headerlink" title="2、    配置环境变量"></a>2、    配置环境变量</h2><p><strong>将安装好的perl的bin路径配置到系统环境变量中</strong></p>
<h2 id="3、-查看是否安装成功-perl-version"><a href="#3、-查看是否安装成功-perl-version" class="headerlink" title="3、    查看是否安装成功(perl -version)"></a>3、    查看是否安装成功(perl -version)</h2><p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210900480.png"></p>
<h2 id="4、-安装NASM（https-www-nasm-us-）"><a href="#4、-安装NASM（https-www-nasm-us-）" class="headerlink" title="4、    安装NASM（https://www.nasm.us/）"></a>4、    安装NASM（<a target="_blank" rel="noopener" href="https://www.nasm.us/%EF%BC%89">https://www.nasm.us/）</a></h2><p><strong>安装完成后将nasm的bin路径配置在系统环境变量中</strong></p>
<h2 id="5、-查看nasm是否安装成功"><a href="#5、-查看nasm是否安装成功" class="headerlink" title="5、    查看nasm是否安装成功"></a>5、    查看nasm是否安装成功</h2><p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210913699.png"></p>
<h2 id="6、-下载openssl-地址（https-github-com-openssl-openssl-download）"><a href="#6、-下载openssl-地址（https-github-com-openssl-openssl-download）" class="headerlink" title="6、     下载openssl 地址（https://github.com/openssl/openssl#download）"></a>6、     下载openssl 地址（<a target="_blank" rel="noopener" href="https://github.com/openssl/openssl#download%EF%BC%89">https://github.com/openssl/openssl#download）</a></h2><h2 id="7、-在解压后的openssl-master目录下创建要保存openssl编译后的目录"><a href="#7、-在解压后的openssl-master目录下创建要保存openssl编译后的目录" class="headerlink" title="7、     在解压后的openssl-master目录下创建要保存openssl编译后的目录"></a>7、     在解压后的openssl-master目录下创建要保存openssl编译后的目录</h2><p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210900602.png"></p>
<h2 id="8、编译openssl"><a href="#8、编译openssl" class="headerlink" title="8、编译openssl"></a>8、编译openssl</h2><p><strong>切换至下载好的openssl目录并输入命令 ：</strong></p>
<p><strong><code>perl Configure VC-WIN64A no-asm --prefix=C:\Users\E0005105\Desktop\tas\openssl-master\openssl-master\VS2019-opens</code>sl</strong></p>
<p><strong>其中：VC-WIN64A表示Windows 64位系统，32位系统换成VC-WIN32，若要使用debug版本，使用debug-VC-WIN64A或debug-VC-WIN32</strong></p>
<p><strong>no-asm 表示不用汇编，不设置此属性，可能会导致编译不过</strong></p>
<p><strong><code>--prefix=C:\Users\E0005105\Desktop\tas\openssl-master\openssl-master\VS2019-openssl</code>将其安装到我所新建的文件夹下，省略会安装在默认路径下</strong></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210900439.png"></p>
<p><strong>输入：<code>nmake</code> 编译库源码</strong> </p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210900752.png"></p>
<p><strong>输入：<code>nmake install</code> 进行安装</strong></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210901680.png"></p>
<p><strong>安装完成后进入安装目录查看，表明成功</strong></p>
<p><img src="https://gitee.com/liang-shenlin/resource/raw/master/img/202112210901632.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blogger/page/2/">2</a><a class="extend next" rel="next" href="/blogger/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="梁申麟"
      src="/blogger/images/cafecat.png">
  <p class="site-author-name" itemprop="name">梁申麟</p>
  <div class="site-description" itemprop="description">吃好喝好，长生不老。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogger/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogger/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liangshenlin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liangshenlin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1065434172@qq.com" title="E-Mail → mailto:1065434172@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">梁申麟</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">23k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">21 分钟</span>
</div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/blogger/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/blogger/lib/anime.min.js"></script>
  <script src="/blogger/lib/velocity/velocity.min.js"></script>
  <script src="/blogger/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogger/js/utils.js"></script>

<script src="/blogger/js/motion.js"></script>


<script src="/blogger/js/schemes/pisces.js"></script>


<script src="/blogger/js/next-boot.js"></script>




  















  

  

</body>
</html>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
